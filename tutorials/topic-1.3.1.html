<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processes & Scheduling</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background-color: white;
            padding: 40px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        h1 {
            color: #2c3e50;
            border-bottom: 4px solid #3498db;
            padding-bottom: 15px;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        h2 {
            color: #2980b9;
            margin-top: 40px;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-left: 5px solid #3498db;
            padding-left: 15px;
        }

        h3 {
            color: #34495e;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        h4 {
            color: #555;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        .info-box {
            background-color: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
        }

        .warning-box {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
        }

        .success-box {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 20px 0;
        }

        .danger-box {
            background-color: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 20px 0;
        }

        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
        }

        pre {
            background-color: #f8f9fa;
            color: #2c3e50;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', Courier, monospace;
            line-height: 1.4;
            border: 1px solid #e0e7f0;
        }

        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: white;
        }

        th {
            background-color: #3498db;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }

        tr:hover {
            background-color: #f5f5f5;
        }

        .diagram {
            background-color: #f9f9f9;
            border: 2px solid #ddd;
            padding: 20px;
            margin: 20px 0;
            font-family: monospace;
            white-space: pre;
            overflow-x: auto;
        }

        .key-concept {
            background-color: #e8f4f8;
            border: 2px solid #3498db;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .visual-example {
            background-color: #f0f8ff;
            border: 2px solid #87ceeb;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .nav-links {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid #ddd;
        }

        .nav-link {
            display: inline-block;
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .nav-link:hover {
            background-color: #2980b9;
        }

        .breadcrumb {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 30px;
            font-size: 0.95em;
        }

        .breadcrumb a {
            color: #3498db;
            text-decoration: none;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }

            h2 {
                font-size: 1.5em;
            }

            .container {
                padding: 20px;
            }

            body {
                padding: 10px;
            }

            table {
                font-size: 0.9em;
            }
        }

        html {
            scroll-behavior: smooth;
        }

        pre:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        a {
            transition: all 0.2s ease;
        }

        .info-box, .warning-box, .success-box, .danger-box {
            transition: transform 0.2s ease;
        }

        .info-box:hover, .warning-box:hover, .success-box:hover, .danger-box:hover {
            transform: translateX(5px);
        }
        .breadcrumb-nav {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 30px;
            font-size: 14px;
            color: #666;
        }

        .breadcrumb-nav a {
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
        }

        .breadcrumb-nav a:hover {
            text-decoration: underline;
            color: #2980b9;
        }

        .breadcrumb-separator {
            color: #ccc;
        }

        .breadcrumb-current {
            color: #2c3e50;
            font-weight: 600;
        }

    </style>
</head>
<body>
    <!-- Breadcrumb Navigation -->
    <div class="breadcrumb-nav">
        <a href="../blog.html">Learning Hub</a>
        <span class="breadcrumb-separator">/</span>
        <a href="./hubs/systems.html">Systems</a>
        <span class="breadcrumb-separator">/</span>
        <span class="breadcrumb-current">Processes & Scheduling</span>
    </div>

    <div class="container">
        <h1>Processes & CPU Scheduling</h1>
        <p style="color: #666; font-style: italic; margin-bottom: 20px;">How Operating Systems Manage Multiple Programs and Allocate CPU Time</p>

        <div class="key-concept">
            <h3>What You'll Learn</h3>
            <ul>
                <li><strong>Process Management</strong> - What processes are and how they're created</li>
                <li><strong>Process States</strong> - The lifecycle from creation to termination</li>
                <li><strong>Context Switching</strong> - How the OS switches between processes</li>
                <li><strong>CPU Scheduling Algorithms</strong> - FCFS, SJF, Round Robin, Priority, and Linux CFS</li>
            </ul>
        </div>

        <h2>1. Process Management</h2>

        <h3>What is a Process?</h3>

        <p>A <strong>process</strong> is a program in execution. It's the <strong>unit of resource allocation</strong> in the OS.</p>

        <div class="key-concept">
            <h4>Process Components</h4>
            <ul>
                <li><strong>Code (Text Segment)</strong> - The executable instructions</li>
                <li><strong>Data Segment</strong> - Global variables</li>
                <li><strong>Heap</strong> - Dynamically allocated memory (malloc, new)</li>
                <li><strong>Stack</strong> - Function call frames, local variables</li>
                <li><strong>Process Control Block (PCB)</strong> - OS metadata about the process</li>
            </ul>
        </div>

        <div class="diagram">
Memory Layout of a Process:

High Address
┌─────────────────────┐
│   Kernel Space      │ (not directly accessible)
├─────────────────────┤
│   Stack             │ ← Grows downward
│   (local vars)      │
│         ↓           │
│                     │
│    (free space)     │
│                     │
│         ↑           │
│   Heap              │ ← Grows upward
│   (malloc/new)      │
├─────────────────────┤
│   Data Segment      │ (global variables)
│   - Initialized     │
│   - Uninitialized   │
├─────────────────────┤
│   Code/Text         │ (executable instructions)
│   (read-only)       │
└─────────────────────┘
Low Address
        </div>

        <h3>Process Control Block (PCB)</h3>

        <p>The PCB is the OS's data structure for tracking a process. It contains:</p>

        <table>
            <thead>
                <tr>
                    <th>Field</th>
                    <th>Description</th>
                    <th>Example Value</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Process ID (PID)</strong></td>
                    <td>Unique identifier</td>
                    <td>1234</td>
                </tr>
                <tr>
                    <td><strong>State</strong></td>
                    <td>Current execution state</td>
                    <td>Running, Ready, Blocked</td>
                </tr>
                <tr>
                    <td><strong>Program Counter (PC)</strong></td>
                    <td>Next instruction address</td>
                    <td>0x400524</td>
                </tr>
                <tr>
                    <td><strong>Registers</strong></td>
                    <td>CPU register values</td>
                    <td>EAX=5, EBX=10, ...</td>
                </tr>
                <tr>
                    <td><strong>Memory Pointers</strong></td>
                    <td>Page table, stack, heap</td>
                    <td>0x7fff0000, ...</td>
                </tr>
                <tr>
                    <td><strong>Open Files</strong></td>
                    <td>File descriptors</td>
                    <td>fd[0]=stdin, fd[3]=log.txt</td>
                </tr>
                <tr>
                    <td><strong>Priority</strong></td>
                    <td>Scheduling priority</td>
                    <td>20 (nice value)</td>
                </tr>
                <tr>
                    <td><strong>CPU Time</strong></td>
                    <td>Time consumed</td>
                    <td>1.2 seconds</td>
                </tr>
            </tbody>
        </table>

        <h3>Process States</h3>

        <div class="diagram">
Process State Diagram:

                    ┌─────────┐
                    │  Start  │
                    └────┬────┘
                         │ fork()
                         ▼
    ┌────────────────────────────────────────────┐
    │              NEW/CREATED                   │
    │  (Process created, PCB allocated)          │
    └────┬───────────────────────────────────────┘
         │ admitted
         ▼
    ┌────────────────────────────────────────────┐
    │              READY                         │
    │  (Waiting for CPU, in ready queue)         │ ◄─────┐
    └────┬───────────────────────────────────────┘       │
         │ scheduled (dispatch)                          │
         ▼                                               │
    ┌────────────────────────────────────────────┐       │
    │              RUNNING                       │       │
    │  (Executing on CPU)                        │       │
    └────┬──────────────────┬─────────────────┬──┘       │
         │                  │                 │          │
         │ I/O request      │ timer interrupt │          │
         │ or wait()        │ or yield()      │          │
         ▼                  └─────────────────┘          │
    ┌────────────────────────────────────────────┐       │
    │              BLOCKED/WAITING               │       │
    │  (Waiting for I/O or event)                │       │
    └────┬───────────────────────────────────────┘       │
         │ I/O complete or event occurs                  │
         └───────────────────────────────────────────────┘

         From RUNNING state, process can also:
                │ exit() or kill
                ▼
         ┌──────────────┐
         │  TERMINATED  │
         └──────────────┘
        </div>

        <h3>Process Creation: fork()</h3>

        <p>In Unix/Linux, processes are created using <code>fork()</code>. It creates an <strong>exact copy</strong> of the calling process!</p>

        <div class="visual-example">
            <h4>Example 1: Basic Fork</h4>
            <pre><code>// fork_example.c
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;

int main() {
    pid_t pid;
    int x = 10;

    printf("Before fork: PID = %d, x = %d\n", getpid(), x);

    pid = fork();  // Create a new process!

    if (pid &lt; 0) {
        // Fork failed
        fprintf(stderr, "Fork failed!\n");
        return 1;
    } else if (pid == 0) {
        // Child process (fork returns 0)
        x = 20;
        printf("CHILD:  PID = %d, Parent PID = %d, x = %d\n",
               getpid(), getppid(), x);
    } else {
        // Parent process (fork returns child's PID)
        x = 30;
        printf("PARENT: PID = %d, Child PID = %d, x = %d\n",
               getpid(), pid, x);
    }

    printf("Both processes reach here: PID = %d, x = %d\n",
           getpid(), x);

    return 0;
}</code></pre>

            <h4>Output:</h4>
            <pre><code>Before fork: PID = 1234, x = 10
PARENT: PID = 1234, Child PID = 1235, x = 30
Both processes reach here: PID = 1234, x = 30
CHILD:  PID = 1235, Parent PID = 1234, x = 20
Both processes reach here: PID = 1235, x = 20</code></pre>
        </div>

        <div class="info-box">
            <strong>Key Insight:</strong> After fork(), there are TWO processes running the same code! They diverge based on the return value of fork():
            <ul>
                <li>Parent receives child's PID</li>
                <li>Child receives 0</li>
                <li>Both continue executing from the same point</li>
            </ul>
        </div>

        <h4>Process Creation Workflow</h4>

        <div class="diagram">
What happens during fork():

Parent Process (PID 1234)          Kernel           Child Process (PID 1235)
────────────────────────────────────────────────────────────────────────────
       │
       │ 1. Call fork()
       ├──────────────────────────►
       │                           Allocate new PID (1235)
       │                           Create new PCB
       │                           Copy page table (virtual memory)
       │                           Copy-on-write for memory pages
       │                           Copy file descriptors
       │                           Copy registers, PC
       │                           Set return value: 1235 for parent
       │                           Set return value: 0 for child
       │                           Add child to ready queue
       │ ◄──────────────────────── ├──────────────────────────►
       │                           │                          │
  fork() = 1235                    │                     fork() = 0
  (child's PID)                    │                     (I'm the child!)
       │                           │                          │
       ▼                           │                          ▼
  Continue execution               │                   Continue execution
       │                           │                          │
        </div>

        <div class="warning-box">
            <strong>Important:</strong> Modern systems use <strong>copy-on-write (COW)</strong> for fork(). Memory isn't actually copied until one process modifies it. This makes fork() very efficient!
        </div>

        <h3>Process Execution: exec()</h3>

        <p>The <code>exec()</code> family of functions <strong>replaces</strong> the current process with a new program.</p>

        <div class="visual-example">
            <h4>Example 2: Fork + Exec</h4>
            <pre><code>// fork_exec.c
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // Child process: run "ls -l" command
        printf("Child: About to execute 'ls -l'\n");

        execlp("ls", "ls", "-l", NULL);

        // If exec succeeds, this line NEVER runs!
        // (current process image is replaced)
        printf("This only prints if exec fails!\n");
    } else {
        // Parent process: wait for child to finish
        printf("Parent: Waiting for child (PID %d)...\n", pid);

        int status;
        wait(&status);  // Wait for child to terminate

        printf("Parent: Child finished with status %d\n", status);
    }

    return 0;
}</code></pre>
        </div>

        <h3>Context Switching</h3>

        <p>When the OS switches the CPU from one process to another, it performs a <strong>context switch</strong>.</p>

        <div class="key-concept">
            <h4>Context Switch Steps</h4>
            <ol>
                <li>Save current process state (registers, PC) to its PCB</li>
                <li>Update process state (Running → Ready or Blocked)</li>
                <li>Move process to appropriate queue</li>
                <li>Select next process to run (scheduling algorithm)</li>
                <li>Load new process state from its PCB</li>
                <li>Switch to new process's page table (memory context)</li>
                <li>Resume execution of new process</li>
            </ol>
        </div>

        <div class="diagram">
Context Switch Timeline:

Process A running          Kernel          Process B running
────────────────────────────────────────────────────────────
      │
      │ Timer interrupt or system call
      ├─────────────────────►
      │                     Save A's state to PCB_A
      │                     - Registers (EAX, EBX, ...)
      │                     - Program Counter
      │                     - Stack Pointer
      │
      │                     Select next process (B)
      │
      │                     Load B's state from PCB_B
      │                     - Restore registers
      │                     - Restore Program Counter
      │                     - Switch page table
      │                     - Flush TLB (expensive!)
      │
      │                     ◄──────────────────────┤
      │                                            │
(process A suspended)                     (process B resumes)
                                                   │

Cost: 1-10 microseconds (1,000-10,000 CPU cycles!)
        </div>

        <h4>Performance Impact of Context Switching</h4>

        <table>
            <thead>
                <tr>
                    <th>Operation</th>
                    <th>Latency</th>
                    <th>Relative Cost</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>L1 cache hit</td>
                    <td>1 ns</td>
                    <td>1×</td>
                </tr>
                <tr>
                    <td>L2 cache hit</td>
                    <td>4 ns</td>
                    <td>4×</td>
                </tr>
                <tr>
                    <td>RAM access</td>
                    <td>100 ns</td>
                    <td>100×</td>
                </tr>
                <tr>
                    <td>System call</td>
                    <td>100-1000 ns</td>
                    <td>100-1000×</td>
                </tr>
                <tr>
                    <td><strong>Context switch</strong></td>
                    <td><strong>1-10 μs</strong></td>
                    <td><strong>1,000-10,000×</strong></td>
                </tr>
                <tr>
                    <td>Disk I/O</td>
                    <td>1-10 ms</td>
                    <td>1,000,000-10,000,000×</td>
                </tr>
            </tbody>
        </table>

        <div class="info-box">
            <strong>Key Insight:</strong> Context switches are expensive! Minimize them in performance-critical code by:
            <ul>
                <li>Using threads instead of processes (lighter context switch)</li>
                <li>Batching I/O operations</li>
                <li>Using async I/O to avoid blocking</li>
            </ul>
        </div>

        <h3>Processes vs Threads</h3>

        <table>
            <thead>
                <tr>
                    <th>Aspect</th>
                    <th>Process</th>
                    <th>Thread</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Definition</strong></td>
                    <td>Independent execution unit</td>
                    <td>Execution unit within a process</td>
                </tr>
                <tr>
                    <td><strong>Memory Space</strong></td>
                    <td>Separate address space</td>
                    <td>Shared address space</td>
                </tr>
                <tr>
                    <td><strong>Creation Cost</strong></td>
                    <td>High (~100 μs)</td>
                    <td>Low (~1 μs)</td>
                </tr>
                <tr>
                    <td><strong>Context Switch</strong></td>
                    <td>Expensive (page table switch)</td>
                    <td>Cheap (same page table)</td>
                </tr>
                <tr>
                    <td><strong>Communication</strong></td>
                    <td>IPC (pipes, sockets)</td>
                    <td>Shared memory (direct)</td>
                </tr>
                <tr>
                    <td><strong>Isolation</strong></td>
                    <td>Strong (protected)</td>
                    <td>Weak (shared memory)</td>
                </tr>
                <tr>
                    <td><strong>When to Use</strong></td>
                    <td>Isolation needed</td>
                    <td>Concurrency within app</td>
                </tr>
            </tbody>
        </table>

        <h2>2. CPU Scheduling</h2>

        <h3>The Scheduling Problem</h3>

        <p>With multiple processes ready to run, which one should get the CPU next? This is the <strong>CPU scheduling</strong> problem.</p>

        <div class="key-concept">
            <h4>Scheduling Goals</h4>
            <ul>
                <li><strong>Fairness</strong> - All processes get a fair share of CPU</li>
                <li><strong>Throughput</strong> - Maximize completed processes per unit time</li>
                <li><strong>Response Time</strong> - Minimize time from request to first response</li>
                <li><strong>Turnaround Time</strong> - Minimize time from arrival to completion</li>
                <li><strong>CPU Utilization</strong> - Keep CPU busy (avoid idle time)</li>
                <li><strong>Waiting Time</strong> - Minimize time spent in ready queue</li>
            </ul>
        </div>

        <h3>Scheduling Algorithms</h3>

        <h4>1. First-Come, First-Served (FCFS)</h4>

        <p><strong>Simplest algorithm:</strong> Process that arrives first gets CPU first.</p>

        <div class="visual-example">
            <h4>Example: FCFS Scheduling</h4>
            <pre><code>Process   Arrival Time   Burst Time
P1        0              24
P2        1              3
P3        2              3

Gantt Chart:
┌────────────────────────────┬───────┬───────┐
│            P1              │  P2   │  P3   │
└────────────────────────────┴───────┴───────┘
0                          24      27      30

Waiting Time:
P1: 0 (started immediately)
P2: 24 - 1 = 23 (arrived at 1, started at 24)
P3: 27 - 2 = 25 (arrived at 2, started at 27)

Average Waiting Time = (0 + 23 + 25) / 3 = 16 ms</code></pre>
        </div>

        <div class="warning-box">
            <strong>Problem: Convoy Effect</strong><br>
            Short processes get stuck behind long ones, like cars behind a slow truck on a one-lane road!
        </div>

        <h4>2. Shortest Job First (SJF)</h4>

        <p><strong>Pick the process with the shortest burst time next.</strong></p>

        <div class="visual-example">
            <h4>Example: SJF Scheduling (Same processes)</h4>
            <pre><code>Process   Arrival Time   Burst Time
P1        0              24
P2        1              3
P3        2              3

With Preemptive SJF (Shortest Remaining Time First - SRTF):
At time 1: P2 arrives with burst=3, P1 has 23 left → Preempt P1!

Gantt Chart (Preemptive):
┌───┬───────┬───────┬─────────────────────────┐
│P1 │  P2   │  P3   │          P1             │
└───┴───────┴───────┴─────────────────────────┘
0   1       4       7                        30

Waiting Time:
P1: (0) + (7-1) = 6 (ran 0-1, waited 1-7, ran 7-30)
P2: 1 - 1 = 0 (arrived at 1, started at 1)
P3: 4 - 2 = 2 (arrived at 2, started at 4)

Average Waiting Time = (6 + 0 + 2) / 3 = 2.67 ms (Much better!)</code></pre>
        </div>

        <div class="info-box">
            <strong>Key Insight:</strong> SJF is <strong>optimal</strong> for minimizing average waiting time, but requires knowing future burst times (impossible in practice!). Used in batch systems where job times are known.
        </div>

        <h4>3. Round Robin (RR)</h4>

        <p><strong>Each process gets a small time slice (quantum), then goes to back of queue.</strong></p>

        <div class="visual-example">
            <h4>Example: Round Robin with Quantum = 4</h4>
            <pre><code>Process   Arrival Time   Burst Time
P1        0              24
P2        1              3
P3        2              3

Gantt Chart (Quantum = 4):
┌──────┬───────┬───────┬──────┬──────┬──────┬──────┬──────┬──────┐
│  P1  │  P2   │  P3   │  P1  │  P1  │  P1  │  P1  │  P1  │  P1  │
└──────┴───────┴───────┴──────┴──────┴──────┴──────┴──────┴──────┘
0      4       7      10     14     18     22     26     30

Time 0-4:   P1 runs (20 left)
Time 4-7:   P2 runs (0 left, finishes)
Time 7-10:  P3 runs (0 left, finishes)
Time 10-14: P1 runs (16 left)
Time 14-18: P1 runs (12 left)
... and so on

Average Waiting Time = higher than SJF, but better response time!</code></pre>
        </div>

        <div class="key-concept">
            <h4>Choosing the Time Quantum</h4>
            <ul>
                <li><strong>Too large:</strong> Degenerates to FCFS (poor response)</li>
                <li><strong>Too small:</strong> Too many context switches (high overhead)</li>
                <li><strong>Typical value:</strong> 10-100 milliseconds</li>
                <li><strong>Rule of thumb:</strong> 80% of bursts should be shorter than quantum</li>
            </ul>
        </div>

        <h4>4. Priority Scheduling</h4>

        <p>Each process has a priority. CPU goes to highest-priority ready process.</p>

        <div class="danger-box">
            <strong>Problem: Starvation</strong><br>
            Low-priority processes may never run if high-priority processes keep arriving!<br><br>
            <strong>Solution: Aging</strong> - Gradually increase priority of waiting processes.
        </div>

        <h4>5. Completely Fair Scheduler (CFS) - Linux</h4>

        <p>Linux's default scheduler since 2.6.23. It aims to give each process an equal share of CPU time.</p>

        <div class="key-concept">
            <h4>CFS Key Concepts</h4>
            <ul>
                <li><strong>Virtual Runtime (vruntime)</strong> - Tracks how much CPU time process has used</li>
                <li><strong>Red-Black Tree</strong> - Processes sorted by vruntime (O(log n) operations)</li>
                <li><strong>Always pick leftmost node</strong> - Process with smallest vruntime</li>
                <li><strong>Nice values</strong> - Adjust process weight (-20 to +19)</li>
                <li><strong>Target latency</strong> - Period over which all processes should run once</li>
            </ul>
        </div>

        <h3>Scheduling Algorithm Comparison</h3>

        <table>
            <thead>
                <tr>
                    <th>Algorithm</th>
                    <th>Pros</th>
                    <th>Cons</th>
                    <th>Best For</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>FCFS</strong></td>
                    <td>Simple, fair order</td>
                    <td>Convoy effect, poor response</td>
                    <td>Batch systems</td>
                </tr>
                <tr>
                    <td><strong>SJF</strong></td>
                    <td>Optimal avg wait time</td>
                    <td>Starvation, need burst time</td>
                    <td>Batch with known times</td>
                </tr>
                <tr>
                    <td><strong>Round Robin</strong></td>
                    <td>Fair, good response</td>
                    <td>High turnaround, context switches</td>
                    <td>Interactive systems</td>
                </tr>
                <tr>
                    <td><strong>Priority</strong></td>
                    <td>Important jobs first</td>
                    <td>Starvation</td>
                    <td>Real-time systems</td>
                </tr>
                <tr>
                    <td><strong>CFS</strong></td>
                    <td>Fair, scalable, no starvation</td>
                    <td>Complex implementation</td>
                    <td>Linux (default)</td>
                </tr>
            </tbody>
        </table>

        <div class="nav-links">
            <a href="topic-1.3.0.html" class="nav-link">← Previous: Overview</a>
            <a href="topic-1.3.2.html" class="nav-link">Next: Virtual Memory →</a>
        </div>

        <hr style="margin: 40px 0; border: none; border-top: 2px solid #ddd;">

        <div style="background-color: #e8f5e9; border-left: 4px solid #4caf50; padding: 15px; margin: 20px 0; border-radius: 5px;">
            <strong>Continue Learning:</strong><br>
            → <a href="topic-1.3.2.html">Topic 1.3.2: Virtual Memory</a> - Deep dive into memory management<br>
            → <a href="topic-1.3.3.html">Topic 1.3.3: I/O & File Systems</a> - Understanding disk I/O and file systems<br>
            → <a href="topic-1.3.4.html">Topic 1.3.4: Synchronization & Concurrency</a> - Master thread synchronization
        </div>
    </div>
</body>
</html>
